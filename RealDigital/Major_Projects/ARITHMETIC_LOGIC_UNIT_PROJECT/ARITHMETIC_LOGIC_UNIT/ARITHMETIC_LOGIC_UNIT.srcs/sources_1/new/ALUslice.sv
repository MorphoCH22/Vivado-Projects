`timescale 1ns / 1ps
/* GOAL: Create a bit-slice design to be used in an 8-bit ALU module with a
 *      instruction set of 16, including addition/subtraction, bitwise operations,
 *      and shifting operations.
 *
 * A and B are individual bits part of respective bytes that are fed into the ALU.
 * Cin carries from the last bit-slice in the sequence, and Cout passes to the next bit-slice.
 * F is the final output generated by A and B based on the opcode provided.
 *
 * Created by: MorphoCH22
 * Board used: RealDigital Blackboard (Xilinx XC7007S ZYNQ)
 */

module ALUslice(
        input [3:0] opcode,
        input A, B, Cin,
        output reg F, Cout
    );
    
    always @(A, B, opcode) begin
    case(opcode)
    4'b0000:        begin //NO OPCODE
                        F <= A; Cout <= 0; 
                        end
    4'b0001:        begin //ADDITION OF A AND B
                        F <= A^B^Cin; Cout <= A&B | (A^B)&Cin; 
                        end
    4'b0010:        begin //INCREMENT A
                        F <= A^Cin; Cout <= A&Cin; 
                        end
    4'b0011:        begin //SUBTRACT B FROM A
                        F <= A^!B^Cin; Cout <= (A&!B) | ((A^!B)&Cin); 
                        end
    4'b0100:        begin //DECREMENT A
                        F <= !A^Cin; Cout <= A | Cin; 
                        end
    4'b0101:        begin //BITWISE XOR BETWEEN A AND B
                        F <= A^B; Cout <= 0; 
                        end
    4'b0110:        begin //BITWISE NOT ON A
                        F <= !A; Cout <= 0; 
                        end
    4'b0111:        begin //BITWISE OR ON A AND B
                        F <= A|B; Cout <= 0; 
                        end
    4'b1000:        begin //BITWISE AND ON A AND B
                        F <= A&B; Cout <= 0; 
                        end
    4'b1001:        begin //BITWISE XNOR ON A AND B
                        F <= !(A^B); Cout <= 0; 
                        end
    4'b1010:        begin //BITWISE NOR ON A AND B
                        F <= !(A|B); Cout <= 0; 
                        end
    4'b1011:        begin //BITWISE NAND ON A AND B
                        F <= !(A&B); Cout <= 0; 
                        end
    default:        begin //NO OPCODE
                        F <= A; Cout <= 0; 
                        end
    endcase
    end
endmodule
